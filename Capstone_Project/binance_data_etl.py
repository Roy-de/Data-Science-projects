import json
from time import time
from datetime import datetime, timedelta
from airflow import DAG
from airflow.operators.python import PythonOperator
from cassandra.auth import PlainTextAuthProvider
from cassandra.cluster import Cluster

default_args = {
    'owner': 'roy',
    'depends_on_past': False,
    'start_date': datetime.utcnow(),
    'email_on_failure': False,
    'email_on_retry': False,
    'retries': 3,
    'retry_delay': timedelta(minutes=5),
}

dag = DAG(
    'binance_data_dag',
    default_args=default_args,
    description='A DAG to fetch and process Binance data',
    schedule=timedelta(days=1),
    catchup=True
)


class CassandraConnector:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super().__new__(cls)
            cls._instance.connect()
        return cls._instance

    def connect(self):
        cloud_config = {
            'secure_connect_bundle': '/home/roy/airflow/dags/binance_etl/secure-connect-crypto.zip'
        }

        with open("/home/roy/airflow/dags/binance_etl/crypto-token.json") as f:
            secrets = json.load(f)

        CLIENT_ID = secrets["clientId"]
        CLIENT_SECRET = secrets["secret"]

        auth_provider = PlainTextAuthProvider(CLIENT_ID, CLIENT_SECRET)
        cluster = Cluster(cloud=cloud_config, auth_provider=auth_provider)
        session = cluster.connect()


# def connect_to_cassandra(**kwargs):
#     cloud_config = {
#         'secure_connect_bundle': '/home/roy/airflow/dags/binance_etl/secure-connect-crypto.zip'
#     }
#
#     # This token JSON file is autogenerated when you download your token,
#     # if yours is different update the file name below
#     with open("/home/roy/airflow/dags/binance_etl/crypto-token.json") as f:
#         secrets = json.load(f)
#
#     CLIENT_ID = secrets["clientId"]
#     CLIENT_SECRET = secrets["secret"]
#
#     auth_provider = PlainTextAuthProvider(CLIENT_ID, CLIENT_SECRET)
#     cluster = Cluster(cloud=cloud_config, auth_provider=auth_provider)
#     session = cluster.connect()
#     session_str = cloudpickle.dumps(session)
#     print("success")
#     kwargs['ti'].xcom_push(key='cassandra_session', value=session_str)

def get_high_low_values():
    cassandra_connector = CassandraConnector()
    session = cassandra_connector.session

    # Query to retrieve data for the last minute (timestamps in seconds)
    one_minute_ago = datetime.utcnow() - timedelta(minutes=1)
    start_timestamp = int((one_minute_ago - datetime(1970, 1, 1)).total_seconds())

    select_query = f"SELECT timestamp, high_price, low_price " \
                   f"FROM btcusd.btcusd_time_series " \
                   f"WHERE timestamp >= {start_timestamp}"

    rows = session.execute(select_query)

    # Calculate highest and lowest values
    highest_value = max(row.high_price for row in rows)
    lowest_value = min(row.low_price for row in rows)

    return highest_value, lowest_value


def get_open_high_low_close_values():
    cassandra_connector = CassandraConnector()
    session = cassandra_connector.session

    # Query to retrieve data for the last minute
    one_minute_ago = time() - 60  # 60 seconds in a minute
    select_query = f"SELECT timestamp, open_price, high_price, low_price, close_price " \
                   f"FROM btcusd.btcusd_time_series " \
                   f"WHERE timestamp >= {one_minute_ago}"

    rows = session.execute(select_query)

    # Extract data from rows
    timestamps = [row.timestamp for row in rows]
    open_prices = [row.open_price for row in rows]
    high_prices = [row.high_price for row in rows]
    low_prices = [row.low_price for row in rows]
    close_prices = [row.close_price for row in rows]

    # Use the first and last values for open and close
    open_price = open_prices[0] if open_prices else None
    close_price = close_prices[-1] if close_prices else None

    # Calculate highest and lowest values
    highest_value = max(high_prices) if high_prices else None
    lowest_value = min(low_prices) if low_prices else None

    return timestamps, open_price, highest_value, lowest_value, close_price


cs_task = PythonOperator(
    task_id='cassandra_task',
    python_callable=CassandraConnector.connect,
    provide_context=True,
    dag=dag,
)
gt_data = PythonOperator(
    task_id="get_high_low_values",
    python_callable=get_high_low_values,
    provide_context=True,
    dag=dag,
)
gt_data_ohlc = PythonOperator(
    task_id="get_open_high_low_close_values",
    python_callable=get_open_high_low_close_values,
    provide_context=True,
    dag=dag,
)

cs_task >> [gt_data, gt_data_ohlc]
